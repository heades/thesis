\input{free-speech-ott}

\renewcommand{\FSdrulename}[1]{\scriptsize \textsc{#1}}

\newcommand{\tvdash}[1]{\vdash^{#1}}
\newcommand{\arrowT}[5]{(#1 :^{#2} #3)^{#4} \to #5}
\newcommand{\rec}[3]{rec\ #1\ #2\ #3}
\newcommand{\recc}[3]{rec^{-}\ #1\ #3}

The requirement that every program must terminate can be relaxed by
first designing a very powerful programming language (PL), and then
carving out two fragments of programs. The first consists of all the
terminating programs called the logical fragment, and the second
consists of all programs, and this is called the programmatic
fragment. That is we have a picture that looks something like:
\begin{center}
  \begin{tikzpicture}[scale=2.5,cap=round,>=latex]
    % draw the unit circle
    \draw[thick] (0cm,0cm) circle(1cm);
    \draw (0cm,0cm) node {PL};
    \draw (1.4cm,0cm) node {\Large $\Longrightarrow$};
    \draw[thick] (2.8cm,0cm) circle(1cm);
    \draw (2.78cm,0cm) node {Programmatic};
    \draw[thick] (3cm,0.51cm) circle(0.3cm);
    \draw (3cm,0.5cm) node {Logical};
  \end{tikzpicture}
\end{center}

Once the logical fragment has been identified three additional features
will need to added.  The first feature is that types in the logical
fragment will need to be able to depend on programs from the
programmatic fragment, but this feature has to be designed so as to
prevent these programs from being applied to any arguments or this
would prevent the logical fragment from being logically consistent.
For an overview of logical consistency and how it can be proven see
Chapter~\ref{chap:metatheory_of_programming_languages}.  We call this
feature freedom of speech, because it intuitively states that logical
types and programs can talk about potentially non-terminating
programs, but they are never allowed to actually run them.  

The second and third features are usability features.  The logical
fragment is purely specificational.  Its primary use is for the
verification of programs written in the programmatic fragment.
Furthermore, carrying around non-computationally interesting proofs is
expensive.  Thus, it is important to allow some specificational data
to be stripped away during compile time.  In addition it is important
that the programmer be the one to decide which data is removed.  Now
logical programs are proofs, but they are also terminating programs,
and thus can be considered both logical programs and programmatic
programs.  The third and final feature is the ability to write
programs in the logical fragment and then move them into the
programmatic fragment.  This facilitates code reuse and provides a
means to write verified terminating programs.

In this chapter we introduce the design of a programming language that
contains all of these features, and some additional ones.  It is
called Freedom of Speech, because it is the first core
dependently-typed functional programming language with the freedom of
speech property.  The syntax and the CBV reduction relation is defined
in Figure~\ref{fig:FS-syn-red}.  
\begin{figure}
  \begin{center}
    \begin{tabular}{lll}
      Syntax:
      \vspace{10px} \\
      \begin{math}
        \arraycolsep=2pt\edef\arraystretch{1.2}
        \begin{array}{rllllllllllllllll}
          \text{(Classifiers)}  & [[th]] & ::= & [[L]]\,|\,[[C]]\\
          \text{(Stages)}       & [[ep]] & ::= & [[+]]\,|\,[[-]]\\
          \text{(Expressions)}  & [[e]]  & ::= & 
          [[x]]\,|\,[[Type]]\,|\,[[Nat]]\,|\,[[(x : th e1) ep -> e2]]\,|\,[[e1 = e2]]\,|\,
          [[S]]\,|\,[[Z]]\,|\,\\
          & & & [[\x.e]]\,|\,[[rec f x e]]\,|\,[[rec - f e]]\,|\,[[e1 e2]]\,|\,
                [[join]]\,|\,[[injdom]]\,|\,[[injran]]\,|\,\\
          & & & [[contra]]\,|\,[[abort]]\\
          \text{(Values)}       & [[v]] & ::= & 
          [[x]]\,|\,[[Type]]\,|\,[[Nat]]\,|\,[[(x : th v1) ep -> v2]]\,|\,
          [[e1 = e2]]\,|\,[[\x.e]]\,|\,\\
          & & & [[join]]\,|\,[[injdom]]\,|\,[[injran]]\,|\,[[rec f x v]]\,|\,[[rec - f v]]\\
          \text{(Evaluation Contexts)} & [[C]] & ::= & [[ [] ]]\,|\,[[( x : th C ) ep -> e2]]\,|\,[[( x : th e1 ) ep -> C]]\,|\,[[rec f x C]]\,|\,\\
          & & & [[rec - f C]]\,|\,[[e1 C]]\,|\,[[C v]]\\
          \text{(Typing Contexts)}     & [[G]] & ::= & [[.]]\,|\,[[x : th e]]\,|\,[[G1,G2]]\\        
        \end{array}
      \end{math}\\
      & \\
      CBV reduction:\\
      \small
      \begin{mathpar}
        \FSdruleCbvXXApp{}  \and
        \FSdruleCbvXXRec{}  \and
        \FSdruleRedXXCtxt{} \and
        \FSdruleRedXXAbort{} \and
        \FSdruleComputeJoin{}
      \end{mathpar}
    \end{tabular}
  \end{center}  
  \caption{Syntax and reduction rules for freedom of speech}
  \label{fig:FS-syn-red}
\end{figure}

\begin{figure}
  \begin{center}
    \begin{mathpar}
      \FSdruleKXXType{}        \and
      \FSdruleKXXNat{}         \and
      \FSdruleKXXPi{}          \and
      \FSdruleKXXEq{}          \and
      \FSdruleVar{}            \and
      \FSdruleLam{}            \and
      \FSdruleILam{}           \and
      \FSdruleAppPiTerm{}      \and
      \FSdruleAppAllTerm{}     \and
      \FSdrulejoin{}           \and
      \FSdruleConv{}           \and
      \FSdruleSucc{}           \and
      \FSdruleZero{}           \and
      \FSdruleAbort{}          \and
      \FSdruleContra{}         \and
      \FSdruleContraAbort{}    \and
      \FSdruleCoerce{}         \and
      \FSdruleRecNat{}         \and
      \FSdruleRecNatComp{}     \and
      \FSdruleRec{}
    \end{mathpar}
  \end{center}
  \caption{Typing rules for freedom of speech}
  \label{fig:FS-typing}
\end{figure}


To prevent equations between $\Pi$-types having different compiletime/runtime arguments or 
different consistency classifiers we add the following rules:

\begin{center}
  \begin{mathpar}
    \FSdruleContraPiTh{} \and
    \FSdruleContraPiEp{}
  \end{mathpar}
\end{center}

There are many types of problems that arise from the absence of $\FSdrulename{ContraPiTh}$
and $\FSdrulename{ContraPiEp}$.
For example, not having this resitrction would allow one to equate programmatic functions taking 
programmatic arguments to programmatic functions taking logical arguments, which would be the 
opposite of the freedom of speech property.  Even worse we could equate logical functions taking
programmatic arguments to logical functions taking logical arguments which breaks the freedom
of speech property.

Currently there exists a counter example to type preservation.  Let $\Gamma$ be 
$X:^L Type, Y:^L Type, x:^L X, $
$u:^L ((\arrowT{a}{\nat}{L}{+}{X}) = (\arrowT{a}{\nat}{L}{+}{Y}))$.  Then
if $\Gamma \tvdash{L} \lambda a.x:\arrowT{a}{\nat}{L}{+}{X}$ and $\Gamma \tvdash{L} Zero:Y$
then $\Gamma \tvdash{L} (\lambda a.x)\ Zero:X$.  By applying $\FSdrulename{Conv}$ and using
the assumption $u$, $\Gamma \tvdash{L} (\lambda a.x)\ Zero:Y$, but 
$(\lambda a.x)\ Zero \redto x$ and $\Gamma \tvdash{L} x:X$.

An easy solution to this problem is to add injectivity axioms for $\Pi$-types.  We define the 
injectivity axioms as follows:
\begin{center}  
  \begin{mathpar}
    \FSdruleInjDom{} \and
    \FSdruleInjRan{}
  \end{mathpar}
\end{center}

There are two rules one for the domain types and a second for the range types.  The second rule 
may seem a bit strange especially the second premise, because we are substiuting a value $v$ for
two free variables of possibily different types.  This is however okay, because from the premises
of $\FSdrulename{InjRan}$ and $\FSdrulename{InjDom}$ and $\FSdrulename{Conv}$ it is easy to
conclude that $\Gamma \tvdash{\theta} v:e'_1$.  By $\FSdrulename{InjDom}$, 
$\Gamma \tvdash{L} injdom:e_1 = e'_1$ and clearly $\Gamma \tvdash{\theta} e_1$ is equivalent to 
$\Gamma \tvdash{\theta} [e_1/x]x$.  Thus by $\FSdrulename{Conv}$,
$\Gamma \tvdash{\theta} [e'_1/x]x$, which is equivalent to
$\Gamma \tvdash{\theta} v:e'_1$.  So $\FSdrulename{InjRan}$ does seem to be sound.
