\section{Normalization of Stratified System F (SSF)}
\label{subsec:normalization_stratified_system_f}
In \cite{Eades:2010} H. Eades and A. Stump show that SSF is
normalizing using a proof method which uses the hereditary
substitution function implicitly.  We find it apparent that the
hereditary substitution technique we have developed throughout this
paper is easier to understand, use, and is more informative with
respect to the hereditary substitution function and its interaction
with the type theory than the implicit version of the proof method.
So in this section we reprove normalization of SSF using the
hereditary function explicitly as we developed throughout this paper.

We extend STLC with predicative polymorphism to obtain a language
first analyzed by D. Leivant and N. Danner in \cite{Leivant:1991}
called Stratified System F.  In terms of programming polymorphism
allows one to define programs of generic type.  For example, $\Lambda
X.\lambda x:X.x$ would be the generic identity function.  This
increases the overall expressive power of the type theory.  In STLC
there is no way of defining the generic identity function.  Now in
terms of logic polymorphism amounts to universal quantification.  So
instead of propositional intuitionistic logic with only implication we
obtain first-order intuitionistic logic with only implication and no
predicates.

Stratified System F, consists of types which are stratified into
levels (or ranks) based on type-quantification.  The types that belong
to level zero have no type-quantification, the types at level one only
quantify over types of level zero, and the types at level $n$ quantify
over the types of level $n-1$.  Stratifying System F into levels
effectively prevents impredicativity, where a type $\phi = \forall
X.\phi'$ quantifies over types including itself.  In Stratified System
F, we can only have $\phi = \forall X:*_n.\phi'$ where $X$ ranges over
the set of types of level $n-1$ which does not include $\phi$.

We consider only the finite version of Stratified System F as proposed by Leivant in 
\cite{Leivant:1991} with some slight modifications.  One of the major differences of 
our version of Stratified System F compared to Leivant's is that we use a  
kinding relation which relates a level to a type with respect to some context, using 
algorithmic type/kind-checking rules. The syntax for Stratified System F can be found 
in the next definition followed by the definition of the reduction rules.
\begin{definition}
  \label{def:syntax_ssf}
  The syntax for terms, types, and kinds:
  \begin{center}
    \begin{tabular}{lll}
      $K$ & $:=$ & $*_0$ $|$ $*_1$             $|$ $\ldots$\\
      $\phi$ & $:=$ & $X$   $|$ $\phi \rightarrow \phi$ $|$ $\forall X:K.\phi$\\
      $t$ & $:=$ & $x$   $|$ $\lambda x:\phi.t$   $|$ $t\ t$ $|$ $\Lambda X:K.t$ $|$ $t[\phi]$\\
    \end{tabular}
  \end{center}
\end{definition}

\begin{definition}
  \label{def:reduction_rules_ssf}
  Full $\beta$-reduction for SSF:
  \begin{center}
    \begin{tabular}{lll}
      $(\Lambda X:*_p.t)[\phi]$ & $\rightsquigarrow$ & $[\phi/X]t$\\
      $(\lambda x:\phi.t)t'$    & $\rightsquigarrow$ & $[t'/x]t$
    \end{tabular}
  \end{center}
\end{definition}
\noindent
As we can see the syntax for SSF is essentionally identical to
STLC except we have added two new terms $\Lambda X:K.t$ and $t[\phi]$.
The former is called a type abstraction while the later is called type
application.  This is where polymorphism is coming in.  A type
abstraction allows one to write a generic program and then type
application allows one to instantiate a generic program with a
concrete type.  In Definition~\ref{def:reduction_rules_ssf} we extend
full $\beta$-reduction to include a new redex for type application.
Both the kinding and typing relations depend on well-formed contexts
which is defined next.
\begin{definition}
  \label{fig:well-formed_ssf}
  Context well-formedness rules:
  \begin{center}
    \begin{tabular}{ccc}
      \begin{math}
        $$\mprset{flushleft}
        \inferrule* [right=] {
        \   
        }{\cdot\ Ok}
      \end{math}
      & 
      \begin{math}
        $$\mprset{flushleft}
        \inferrule* [right=] {
          \Gamma\ Ok
        }{\Gamma,X:*_p\ Ok}
      \end{math}
      &
      \begin{math}
        $$\mprset{flushleft}
        \inferrule* [right=] {
          \Gamma \vdash \phi:*_p
          \\
          \Gamma\ Ok
        }{\Gamma,x :\phi\ Ok}
      \end{math} 
    \end{tabular}	
  \end{center}
\end{definition}
\noindent
As stated before we use kinds to denote the level of a type.  We define algorithmic kind-checking 
rules in the following definition.  
\begin{definition}
  \label{fig:l_kinding_rules}
  The kind assignment rules for SSF are defined as follows:
  \begin{center}
    \begin{tabular}{cccc}
      \begin{math}
        $$\mprset{flushleft}
        \inferrule* [right=] {
          \Gamma \vdash \phi_1 : *_p
          \\
          \Gamma \vdash \phi_2 : *_q
        }{\Gamma \vdash \phi_1 \rightarrow \phi_2 : *_{max(p,q)}}
      \end{math}
      & 
      \begin{math}
        $$\mprset{flushleft}
        \inferrule* [right=] {
          \Gamma,X : *_q \vdash \phi : *_p
        }{\Gamma \vdash \forall X:*_q.\phi : *_{max(p,q)+1}}
      \end{math}
      &
      \begin{math}
        $$\mprset{flushleft}
        \inferrule* [right=] {
          \Gamma(X) = *_p
          \\
          p \leq q
          \\
          \Gamma\ Ok
        }{\Gamma \vdash X : *_q}
      \end{math} 
      & \\
    \end{tabular}	
  \end{center}
\end{definition}
\noindent
The context $\Gamma$, type $\phi$, and kind $*_l$ are inputs and there
are no outputs.  In the previous definition we extended STLC with
kinding rules.  These rules serve the exact same purpose as typing
rules, but instead of typing terms they type types.  They insure that
types are well-formed.  Here types are well-formed when they have the
proper leveling assigned to them. The following lemma shows that all
kindable types are kindable with respect to a well-formed context.
\begin{lemma}
	If $\Gamma \vdash \phi:*_p$ then $\Gamma\ Ok$.
	\label{lemma:kinding_ok_ssf}
\end{lemma}
\noindent
The previous lemma insures that if a type is kindable then we could
not have used a ``bogus'' context where we assume something we are not
allowed to assume.  We define algorithmic type-checking rules in the
next definition.
\begin{definition}
  \label{fig:typing_rules_ssf}
  Type assignment rules for SSF:
  \begin{center}
    \begin{tabular}{cccc}
      \begin{math}
        $$\mprset{flushleft}
        \inferrule* [right=] {
          \Gamma(x) = \phi
          \\
          \Gamma\ Ok
        }{\Gamma \vdash x : \phi}
      \end{math}  
      &
      \begin{math}
        $$\mprset{flushleft}
        \inferrule* [right=] {
          \Gamma,x : \phi_1 \vdash t : \phi_2
        }{\Gamma \vdash \lambda x : \phi_1.t : \phi_1 \rightarrow \phi_2}
      \end{math} 
      &
      \begin{math}
        $$\mprset{flushleft}
        \inferrule* [right=] {
          \Gamma \vdash t_1 : \phi_1 \rightarrow \phi_2 
          \\
          \Gamma \vdash t_2 : \phi_1
        }{\Gamma \vdash t_1\ t_2 : \phi_2}
      \end{math}  \\
      \\ 
      \begin{math}
        $$\mprset{flushleft}
        \inferrule* [right=] {
          \Gamma, X : *_p \vdash t : \phi
        }{\Gamma \vdash \Lambda X:*_p.t:\forall X : *_p.\phi}
      \end{math} 
      &
      \begin{math}
        $$\mprset{flushleft}
        \inferrule* [right=] {
          \Gamma \vdash t:\forall X:*_l.\phi_1
          \\
          \Gamma \vdash \phi_2:*_l
        }{\Gamma \vdash t[\phi_2]: [\phi_2/X]\phi_1}
      \end{math} 
      & \\
    \end{tabular}
  \end{center}
\end{definition}  
\noindent
The type-checking rules depend on the kinding relation defined above.
As with the earlier parts of the language we extend the type-checking
rules with rules for type abstraction and type application.  Note that
the level of the type $\phi$ and the level of the type variable $X$ in
the type application rule must be the same.
% subsection the_language (end)

\subsection{Basic Syntactic Lemmas}
\label{subsec:basic_syntactic_lemmas}
We now state several results about the kinding relation. All of these
are just basic results needed by the proofs of the key lemmas and
theorems later. The reader may wish to just quickly read through them.
In Section~\ref{subsec:well-founded_ordering_on_types_ssf} we will define an
ordering on types and prove that it is well founded.  This proof
depends on the following lemma.
Lemma~\ref{lemma:level_weakening_for_kinding_ssf} shows that if a type
is kindable at some level then it is also kindable at strictly larger
levels.

\begin{lemma}[Level Weakening for Kinding]
  If $\Gamma \vdash \phi:*_r$ and $r < s$ then $\Gamma \vdash \phi:*_s$.
  \label{lemma:level_weakening_for_kinding_ssf}
\end{lemma}

\noindent Lemma~\ref{lemma:substitution_for_kinding_ssf} is used in
the proof of Substitution for Typing
(Lemma~\ref{lemma:type_sub_ssf}),
Lemma~\ref{lemma:context_strengthening_for_kinding_ssf} is used in the
main substitution lemma
(Lemma~\ref{lemma:interpretation_of_types_closed_substitution_ssf}),
and Lemma~\ref{lemma:context_weakening_for_kinding_ssf} is used in the
proof of Context Weakening for the Interpretation of Types
(Lemma~\ref{lemma:context_weakening_interpretations_ssf}).

\begin{lemma}[Substitution for Kinding, Context-Ok]
  Suppose $\Gamma \vdash \phi':*_p$.  If $\Gamma,X:*_p,\Gamma' \vdash \phi:*_q$ 
  with a derivation of depth $d$, then $\Gamma,[\phi'/X]\Gamma' \vdash [\phi'/X]\phi:*_q$
  with a derivation of depth $d$.
  Also, if $\Gamma,X:*_p,\Gamma'\ Ok$ with a derivation of depth $d$, then 
  $\Gamma,[\phi'/X]\Gamma'\ Ok$ with a derivation of depth $d$.
  \label{lemma:substitution_for_kinding_ssf}
\end{lemma}

\begin{lemma}[Context Strengthening for Kinding, Context-Ok]
  If $\Gamma,x:\phi',\Gamma' \vdash \phi:*_p$ with a derivation of depth $d$, then 
  $\Gamma,\Gamma' \vdash \phi:*_p$ with a derivation of depth $d$.  Also, if 
  $\Gamma,x:\phi,\Gamma'\ Ok$ with a 
  derivation of depth $d$, then $\Gamma,\Gamma'\ Ok$ with a derivation of depth $d$.
  \label{lemma:context_strengthening_for_kinding_ssf}
\end{lemma}

\begin{lemma}[Context Weakening for Kinding]
  If $\Gamma,\Gamma'',\Gamma'\ Ok$, and $\Gamma,\Gamma' \vdash \phi:*_p$ each with a 
  derivation of depth $d$ then $\Gamma,\Gamma'',\Gamma' \vdash \phi:*_p$ with a 
  derivation of depth $d$.
  \label{lemma:context_weakening_for_kinding_ssf}
\end{lemma}

\begin{lemma}[Regularity]
  If $\Gamma \vdash t:\phi$ then $\Gamma \vdash \phi:*_p$ for some $p$.
  \label{lemma:regularity_ssf}
\end{lemma}
\noindent
We have stated all the basic lemmas we will need.  We now step through
our template outlined in
Section~\ref{sec:normalization_by_hereditary_substitution} to conclude
normalization for SSF.
% subsection basic_syntactic_lemmas (end)

\subsection{Well-Founded Ordering on Types}
\label{subsec:well-founded_ordering_on_types_ssf}
The following definition defines a well-founded ordering on the types
of SSF.  It consists of essentially the strict-subexpression ordering
with an additional case for universal types.  For the case of
universal types the ordering states that a universal type is always
larger than the instantiation of the body of the universal type.  Now
this seems odd, because syntactically the instantiation could have
increased the size of $\phi$ to be larger than the size of the
universal type, but it turns out that the level of the
type actually decreases.  That is we know the level of the universal
type is larger than the level of the instantiation.
\begin{definition}
  The ordering $>_\Gamma$ is defined as the least relation satisfying the universal closures of 
  the following formulas:
  \begin{center}
    \begin{tabular}{lll}
      \begin{tabular}{lll}
        $\phi_1 \rightarrow \phi_2$ & $>_\Gamma$ & $\phi_1$\\
        $\phi_1 \rightarrow \phi_2$ & $>_\Gamma$ & $\phi_2$\\
        $\forall X:*_l.\phi$        & $>_\Gamma$ & $[\phi'/X]\phi$ where 
        $\Gamma \vdash \phi':*_l$.\\
      \end{tabular}
    \end{tabular}
  \end{center}
  \label{def:ordering_ssf}
\end{definition}

\noindent
We need transitivity in a number of places so we state that next.

\begin{lemma}[Transitivity of $>_\Gamma$]
  Let $\phi$, $\phi'$, and $\phi''$ be kindable types.  If $\phi >_\Gamma \phi'$ and 
  $\phi' >_\Gamma \phi''$ then $\phi >_\Gamma \phi''$.
  \label{lemma:transitivity_ssf}
\end{lemma}

\noindent
To prove that the ordering on types ($>_\Gamma$) is well founded we need
a function which computes the depth of a type.  We will use this in a
lexicographic ordering in the proof of
Lemma~\ref{lemma:well-founded_measure_ssf} and is vital to showing
that our ordering on types is well founded.

\begin{definition}
  The depth of a type $\phi$ is defined as follows:
  \begin{center}
    \begin{tabular}{lll}
      $depth(X)$                  & $=$ & $1$\\
      $depth(\phi \to \phi')$     & $=$ & $depth(\phi) + depth(\phi')$\\
      $depth(\forall X:*_l.\phi)$ & $=$ & $depth(\phi) + 1$\\
    \end{tabular}
  \end{center}
\end{definition}

We define the following metric $(l,d)$ in lexicographic combination,
where $l$ is the level of a type $\phi$ and $d$ is the depth of
$\phi$.  The following lemma shows that if $\phi >_\Gamma \phi'$ then
$(l,d) > (l',d')$.  We will use this lemma to show well-foundedness of
the ordering on types $>_\Gamma$.  

\begin{lemma}[Well-Founded Measure]
  \label{lemma:well-founded_measure_ssf}
  If $\phi >_\Gamma \phi'$ then $(l,d) > (l',d')$, where $\Gamma \vdash \phi:*_l$, 
  $depth(\phi) = d$,  $\Gamma \vdash \phi:*_{l'}$, and $depth(\phi') = d'$.
\end{lemma}

\noindent We now have the desired results to prove that the ordering $>_\Gamma$ is 
well-founded.

\begin{thm}[Well-Founded Ordering]
  The ordering $>_\Gamma$ is well-founded on types $\phi$ such that 
  $\Gamma \vdash \phi:*_l$ for some $l$.
  \label{thm:well-founded_ordering_ssf}
\end{thm}
% subsection well-founded_ordering_on_types (end)

\subsection{The Hereditary Substitution Function}
\label{subsec:the_hereditary_substitution_function}
Moving forward with our proof of normalization based on our template
we now need to define the hereditary substitution function for SSF.
The definition of the hereditary substitution function is a basic
extension of hereditary substitution function for STLC.  Before
defining the hereditary substitution function we first define the
construct type function for SSF.  This function is now defined for
three different types of input.  It is defined for variables and
applications just as before with the addition of type application.
\begin{definition}
  \label{def:ctype_function_ssf}
  The construct type function for SSF is defined as follows:
  \begin{itemize}
  \item[] $ctype_\phi(x,x) = \phi$
  \item[]
  \item[] $ctype_\phi(x,t_1\ t_2) = \phi''$\\
    \begin{tabular}{lll}
      & Where $ctype_\phi(x,t_1) = \phi' \to \phi''$.
    \end{tabular}    
  \item[]
  \item[] $ctype_\phi(x,t[\phi']) = [\phi'/X]\phi''$\\
    \begin{tabular}{lll}
      & Where $ctype_\phi(x,t) = \forall X:*_l.\phi''$.
    \end{tabular}    
  \end{itemize}
\end{definition}

\noindent
Finally, we can define the hereditary substitution function for SSF.
\begin{definition}
  \label{def:hereditary_substitution_ssf}
  We define the hereditary substitution function for SSF as follows:
  \begin{itemize}
  \item[] $[t/x]^\phi x = t$
  \item[] $[t/x]^\phi y = y$\\
    \begin{tabular}{lll}
      & Where $y$ is a variable distinct from $x$.\\
    \end{tabular}
  \item[]
  \item[] $[t/x]^\phi (\lambda y:\phi'.t') = \lambda y:\phi'.([t/x]^\phi t')$
  \item[] $[t/x]^\phi (\Lambda X:*_l.t') = \Lambda X:*_l.([t/x]^\phi t')$
  \item[]
  \item[] $[t/x]^\phi (t_1\ t_2) = ([t/x]^\phi t_1)\ ([t/x]^\phi t_2)$\\
    \begin{tabular}{lll}
      & Where $([t/x]^\phi t_1)$ is not a $\lambda$-abstraction, or 
      both $([t/x]^\phi t_1)$ and $t_1$ are $\lambda$-abstractions, \\
      & or $ctype_\phi(x,t_1)$ is undefined.
    \end{tabular}
  \item[]
  \item[] $[t/x]^{\phi} (t_1\ t_2) = [([t/x]^{\phi} t_2)/y]^{\phi''} s'_1$\\
    \begin{tabular}{lll}
      & Where $([t/x]^{\phi} t_1) \equiv \lambda y:\phi''.s'_1$ 
      for some $y$, $s'_1$, and $\phi''$ and $ctype_\phi(x,t_1) = \phi'' \to \phi'$.
    \end{tabular}
  \item[] 
  \item[] $[t/x]^\phi (t'[\phi']) = ([t/x]^\phi t')[\phi']$\\
    \begin{tabular}{lll}
      & Where $[t/x]^\phi t'$ is not a type abstraction or
      $t'$ and $[t/x]^\phi t'$ are type abstractions.
    \end{tabular}
    \item[]
    \item[] $[t/x]^{\phi} (t'[\phi']) = [\phi'/X]s'_1$\\
      \begin{tabular}{lll}
        & Where $[t/x]^{\phi} t' \equiv \Lambda X:*_l.s'_1$,
        for some $X$, $s'_1$ and $\Gamma \vdash \phi':*_q$, 
        such that, $q \leq l$ and \\
        & $ctype_\phi(x,t') = \forall X:*_l.\phi''$.
      \end{tabular}
  \end{itemize}
\end{definition}

\noindent The next lemma states the familiar properties of the
construct type function.  The first property is slightly different
then the one defined for STLC.  The difference arises from the fact
that the ordering on types is not just the subexpression ordering, but
relies on the level of the type in order to order universal types.  So
instead of $\phi$ being a subexpression of the output of $ctype_\phi$
it will be greater than or equal to the output of $ctype_\phi$.  The
remainder of the properties are as usual.

\begin{lemma}[Properties of $ctype_\phi$]
  \label{lemma:ctype_props_ssf}
  \begin{itemize}
  \item[]
  \item[i.] If $\Gamma,x:\phi,\Gamma' \vdash t:\phi'$ and $ctype_\phi(x,t) = \phi''$ then 
    $head(t) = x$, $\phi' \equiv \phi''$, and $\phi' \leq_{\Gamma,\Gamma'} \phi$.

  \item[ii.] If $\Gamma,x:\phi,\Gamma' \vdash t_1\ t_2:\phi'$, $\Gamma \vdash t:\phi$,
    $[t/x]^\phi t_1 = \lambda y:\phi_1.q$, and $t_1$ is not then there exists a type
    $\psi$ such that $ctype_\phi(x,t_1) = \psi$.

  \item[iii.] If $\Gamma,x:\phi,\Gamma' \vdash t'[\phi'']:\phi'$, $\Gamma \vdash t:\phi$,
    $[t/x]^\phi t' = \Lambda X:*_l.t''$, and $t'$ is not then there exists a type
    $\psi$ such that $ctype_\phi(x,t') = \psi$.
  \end{itemize}
\end{lemma}
% subsubsection the_hereditary_substitution_function (end)

\subsection{Properties of the Hereditary Substitution Function}
\label{sec:properties_of_the_hereditary_substitution_function_ssf}
We now extend $rset$ to add type application redexes to the set of overall redexes
of a term.  It is defined in the following definition.  
\begin{definition}
  \label{def:rset_ssf}
  The following function constructs the set of redexes within a term:

  \begin{center}
    \begin{itemize}
    \item[] $rset(x) = \emptyset$\\
    \item[] $rset(\lambda x:\phi.t) = rset(t)$\\
    \item[] $rset(\Lambda X:*_l.t) = rset(t)$\\
    \item[] $rset(t_1\ t_2)$\\
      \begin{math}
        \begin{array}{lll}
          = & rset(t_1, t_2) & \text{if } t_1 \text{ is not a } \lambda \text{-abstraction.}\\
          = & \{t_1\ t_2\} \cup rset(t'_1, t_2)\ & \text{if } t_1 \equiv \lambda x:\phi.t'_1.\\
        \end{array}
      \end{math}
    \item[] $rset(t''[\phi''])$\\
      \begin{math}
        \begin{array}{lll}
          = & rset(t'') & \text{if } t'' \text{ is not a type abstraction.}\\
          = & \{t''[\phi'']\} \cup rset(t''') & \text{if } t'' \equiv \Lambda X:*_l.t'''.
        \end{array}
      \end{math}
    \end{itemize}
  \end{center}
  \ \\
  The extension of $rset$ to multiple arguments is defined as follows:
  \begin{center}
    $rset(t_1, \ldots, t_n) =^{def} rset(t_1) \cup \cdots \cup rset(t_n)$.
  \end{center}
\end{definition}
\noindent Next we state all the properties of the hereditary
substitution function.  They are equivalent to the properties stated
in
Section~\ref{subsec:properties_of_the_hereditary_substitution_function}
the only difference are their proofs.
\begin{lemma}[Total and Type Preserving]
  \label{lemma:total_ssf}
  Suppose $\Gamma \vdash t : \phi$ and $\Gamma, x:\phi, \Gamma' \vdash t':\phi'$. Then
  there exists a term $t''$ such that $[t/x]^\phi t' = t''$ and $\Gamma,\Gamma' \vdash t'':\phi'$.
\end{lemma}

\begin{lemma}[Redex Preserving]
  \label{lemma:redex_preserving_ssf}
  If $\Gamma \vdash t : \phi$, $\Gamma, x:\phi, \Gamma' \vdash t':\phi'$ then
  $|rset(t', t)| \geq |rset([t/x]^\phi t')|$.
\end{lemma}

\begin{lemma}[Normality Preserving]
  \label{corollary:normalization_preserving_ssf}
  If $\Gamma \vdash n:\phi$ and $\Gamma, x:\phi \vdash n':\phi'$ then there exists a normal term $n''$ 
  such that $[n/x]^\phi n' = n''$.
\end{lemma}

\begin{lemma}[Soundness with Respect to Reduction]
  \label{lemma:soundness_reduction_ssf}
  If $\Gamma \vdash t : \phi$ and $\Gamma, x:\phi, \Gamma' \vdash t':\phi'$ then
  $[t/x]t' \redto^* [t/x]^\phi t'$.
\end{lemma}
% subsection properties_of_the_hereditary_substitution_function_ssf (end)

\subsection{Substitution for the Interpretation of Types.}
\label{subsec:substitution_for_the_interpretation_of_types_ssf}
The definition of the interpretation of types is identical to the
definition in
Section~\ref{sec:normalization_the_simply_typed_lambda-calculus}
so we do not repeat it here.  Before concluding normalization we state
the main substitution lemma for the interpretation of types.
\begin{lemma}[Substitution for the Interpretation of Types]
  If $n' \in \interp{\phi'}_{\Gamma,x:\phi,\Gamma'}$, $n \in \interp{\phi}_\Gamma$, then 
  $[n/x]^\phi n' \in \interp{\phi'}_{\Gamma,\Gamma'}$.
  
  \label{lemma:interpretation_of_types_closed_substitution_ssf}
\end{lemma}
\begin{proof}
  By Lemma~\ref{lemma:total_ssf} we know there exists a term $\hat{n}$ 
  such that $[n/x]^\phi n' = \hat{n}$ and $\Gamma,\Gamma' \vdash \hat{n}:\phi'$ and by 
  Lemma~\ref{corollary:normalization_preserving_ssf} $\hat{n}$ is normal.  Therefore,
  $[n/x]^\phi n' = \hat{n} \in \interp{\phi'}_{\Gamma,\Gamma'}$.
\end{proof}

Before moving on to proving soundness of typing and concluding
normalization we need a couple of results about the interpretation of
types: context weakening and type substitution.  They both are used in
the proof of the type soundness theorem
(Theorem~\ref{thm:soundness_ssf}).

\begin{lemma}[Context Weakening for Interpretations of Types]
  If $\Gamma,\Gamma',\Gamma''\ Ok$ and $n \in \interp{\phi}_{\Gamma,\Gamma''}$ then 
  $n \in \interp{\phi}_{\Gamma,\Gamma',\Gamma''}$.
  \label{lemma:context_weakening_interpretations_ssf}
\end{lemma}

\begin{lemma}[Type Substitution for the Interpretation of Types]
  If $n \in \interp{\phi'}_{\Gamma,X:*_l,\Gamma'}$ and 
  $\Gamma \vdash \phi:*_l$ then 
  $[\phi/X]n \in \interp{[\phi/X]\phi'}_{\Gamma,[\phi/X]\Gamma'}$.
  \label{lemma:type_sub_ssf}
\end{lemma}
% subsubsection substitution_for_the_interpretation_of_types_ssf (end)

\subsection{Concluding Normalization.}
\label{subsec:soundness_of_typing_ssf}
We are now ready to present our main result.  The next theorem shows
that the type-assignment rules are sound with respect to the
interpretation of types.  

\begin{thm}[Type Soundness]
  If $\Gamma \vdash t:\phi$ then $t \in \interp{\phi}_\Gamma$.
  \label{thm:soundness_ssf}
\end{thm}
\noindent Therefore, we conclude normalization of SSF.
\begin{corollary}[Normalization]
  If $\Gamma \vdash t:\phi$ then $t \normto n$.
\end{corollary}
% subsubsection concluding_normalization_ssf (end)
% subsection normalization_stratified_system_f (end)