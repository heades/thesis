An entire class of type theories called Pure Type Systems may be
expressed by a very simple core type theory, a set of type universes
called sorts and a set of rules.  The rules specify how the sorts are
to be used.  The rules govern what dependencies are allowed in the
type theory.  There is a special class of eight pure type systems with
only two sorts called $\Box$ and $*$\footnote{ It is also standard to
called these $\mathsf{Type}$ and $Prop$ respectively.  $\mathsf{Type}$
is the same as we have seen above and $\mathsf{Prop}$ is like
$\mathsf{True}$ of Martin-L\"of's type theory.  Its inhabitants are
valid constructive propositions.}.  The following language expresses
the language of this class of types theories.
\begin{definition}
  \label{def:pst_syntax}
  The language of Pure Type Systems:
  \begin{center}
    \begin{math}
      \begin{array}{lll}
        s & ::= & \Box\,|\,*\\
        [[t]],[[a]],[[b]] & ::= & 
            \Box\,|\,*\,|\,[[x]]\,|\,\mathsf{c}\,|\,[[t1 t2]]\,|\,[[\x:t1.t2]]\,|\,[[(x:t1)->t2]]\\
      \end{array}
    \end{math}
  \end{center}
\end{definition}
\noindent
Notice in the previous definition that terms and types are members of
the same language. They are not separated into two syntactic
categories.  This is one of the beauties of pure type systems.  They
have a really clean syntax, but this beauty comes with a cost.  Some
collapsed type theories are very hard to reason about.

Every pure type system has a particular set of inference rules defined
in terms of a specific set of pairs of sorts we denote $S$.  This set
governs the expressive power of the type theory.  It states which
objects of the language depend on which. There are four forms of
dependencies:
\begin{center}
  \begin{tabular}{lll}
    i.   & terms depend on terms: & $(*,*)$\\
    ii.  & terms depend on types: & $(\Box,*)$\\
    iii. & types depend on types: & $(\Box,\Box)$\\
    iv.  & types depend on terms: & $(*,\Box)$
  \end{tabular}  
\end{center}
Terms always depend on terms. For example, $[[(\x:t.a) b]]$ is a term
depending on a term and $\lambda [[x]]:[[Type]].[[b]]$ where $[[b]]$ is a type is
a type depending on a type.  An example of a term depending on a type
is the $\Lambda$-abstraction of system F.  Finally, an example of a
type depending on a term is the product type of Martin-L\"of's Type
Theory.  Now using the notion of dependency we define the core set of
inference rules in the next definition.
\begin{definition}
  \label{def:pst_rules}
  In the following set of inference rules $(s_1,s_2) \in S$ for some
  $S$.  The inference rules of Pure Type Systems:
  \begin{center}
    \begin{math}
      \begin{array}{lll}
        $$\mprset{flushleft}
        \inferrule* [right=Beta] {
          \ 
        }{[[(\x:t.b) a]] \to [[ [a/x]b]]}
        &
        $$\mprset{flushleft}
        \inferrule* [right=Ax] {
          \ 
        }{[[.]] \vdash * : \Box}
        &
        $$\mprset{flushleft}
        \inferrule* [right=Var] {
          [[G]] \vdash [[a]] : s          
        }{[[G, x: a |- x : a]]}\\
        &\\
        $$\mprset{flushleft}
        \inferrule* [right=Weakening] {
          [[G |- a : b]]
          \\\\
          [[G]] \vdash [[c]] : s
          \\
          [[(x:a') \in G]]
        }{[[G,x:c |- a:b]]}
        &
        $$\mprset{flushleft}
        \inferrule* [right=App] {
          [[G |- b : t1]]
          \\\\
          [[G |- a : (x : t1) -> t2]]
        }{[[G |- a b : [b/x]t2]]}
        &
        $$\mprset{flushleft}
        \inferrule* [right=Conv] {
          [[G |- a : b]]
          \\\\
          [[G]] \vdash [[b']]:s
          \\
          [[b]] \equiv_\beta [[b']]
        }{[[G |- a : b']]}\\
        &\\
        $$\mprset{flushleft}
        \inferrule* [right=Pi] {
          [[G]] \vdash [[a]]:s_1
          \\
          [[G,x:a]] \vdash [[b]]:s_2
        }{[[G]] \vdash [[(x:a) -> b]]:s_2}
        &
        $$\mprset{flushleft}
        \inferrule* [right=Lam] {
          [[G,x:a]] \vdash [[b]] : s_2
          \\\\
          [[G,x:a |- c : b]]          
          \\
          [[G]] \vdash a : s_1          
        }{[[G |- \x:a.c:(x : a) -> b]]}
      \end{array}
    \end{math}
  \end{center}
\end{definition}
In the previous definition we left out the congruence rules for
reduction to make the definition more compact.  However, either they
need to be added or evaluation contexts do for a full treatment of
reduction.  It turns out that this is all we need to define every
intuitionistic type theory we have defined in this article including a
few others we have not define. However, Martin-L\"of's Type Theory and
SSF are not definable as a pure type system.  Taking the set $S$ to be
$\{ (*,*)
\}$ results in STLC.  System F results from taking the set $S = \{
(*,*),(\Box,*) \}$. System $\Fw$ is definable by the set $S =
\{(*,*),(\Box,*),(\Box,\Box)\}$.  The eight different type
theories definable in this fashion make up what Hank Barendregt
calls the $\lambda$-cube \cite{Barendregt:1992}.  

A good question now to ask is what type theory results from adding all
possible rules to $S$?  That is what type theory is defined by $S = \{
(*,*), (*, \Box), (\Box,*), (\Box,\Box)\}$?  This type theory is
clearly a dependent type theory and is called the Calculus of
Constructions (CoC).  It was first defined by Thierry Coquand in
\cite{Coquand:1988}.  It is the most powerful of all the eight pure type
system in the $\lambda$-cube.  We have seen one formulation of CoC as
a pure type system, but we give two more.  The first is in the fashion
Coquand originally used in his paper
\cite{Coquand:1988}, and the second is as an extension to system
$\Fw$.  

Coquand used a collapsed syntax originally and based this off
of Automath which did the same.  The syntax he used for CoC is defined
in Fig.~\ref{fig:CoC_syntax}.
\begin{figure}
  \begin{center}
    \begin{math}
      \begin{array}{lll}
        [[t]], [[a]], [[b]], [[c]] & ::= &
        [[Type]]\,|\,[[x]]\,|\,[[\ x : t . t']]\,|\,[[t1 t2]]\,|\,[[(
            x : a ) -> b]]\\
      \end{array}
    \end{math}
  \end{center}
  \caption{Syntax of the Calculus of Constructions}
  \label{fig:CoC_syntax}
\end{figure}
One really neat idea Coquand used was to model context by a dependent
product over $[[Type]]$.  As we have seen it is usually the case
that contexts are understood as just a list of pairs of variables with
their types, but in dependent type theory they have an additional
constraint.  Order matters within typing context for dependent type
theories, because we may have $[[x]]:[[t]],[[y]]:[[t']]$ where
$[[t']]$ depends on $[[x]]$.  So Coquand used the dependent product
over $[[Type]]$ as typeing contexts.  Valid contexts are defined in
Fig.~\ref{fig:CoC_valid_contexts}.
\begin{figure}
  \begin{center}
    \begin{math}
      \begin{array}{lll}
        \CoCdruleCtx{} & \CoCdruleEmpty{}\\ 
        &\\
        \CoCdruleFam{} & \CoCdruleExt{}
      \end{array}
    \end{math}
  \end{center}
  
  \caption{Valid Contexts in the Calculus of Constructions}
  \label{fig:CoC_valid_contexts}
\end{figure}
We write $[[G,x:t]]$ for $[[G]] \to ([[x]] : [[t]]) \to [[Type]]$ and
$[[G,x:G']]$ for $[[G]] \to ([[x]] : [[G']]) \to [[Type]]$.  Note that
the empty context is just $[[Type]]$.  The valid context judgment is
important, because typing context need to be variables with their
types, but since types and terms are collapsed we need to make sure
that all types in the context are actually types.  One finally remark
on valid contexts. Notice that we do not have $[[Type]]:[[Type]]$, but
Coquand allowed for the assumption of type families over $[[Type]]$.
That is we can assume $[[x]]:([[y]] : [[t]]) \to [[Type]]$ even though
$([[y]] : [[t]]) \to [[Type]]$ is not a type.  We know this is
not a type by the typing rules which are defined in
Fig.~\ref{fig:CoC_typing}.
\begin{figure}
  \begin{center}
    \begin{math}
      \begin{array}{lll}
        \CoCdruleTXXProd{} & \CoCdruleTXXVar{}\\
        &\\
        \CoCdruleTXXLam{} & \CoCdruleTXXApp{}\\
        &\\
        \CoCdruleTXXConv{}
      \end{array}
    \end{math}
  \end{center}
  \caption{Typing for the Calculus of Constructions}
  \label{fig:CoC_typing}
\end{figure}

The typing rules do not differ from the rules for PTS'.  We do not
state the operational semantics for these type theories, because it is
just as we have seen before.  It is standard full $\beta$-reduction,
and it can be inferred from the rules of the equality judgment which
is just full $\beta$-equality.  The equality judgment is used by the
\CoCdrulename{T\_Conv} typing rule.  This rule says that if we have a
term of one type which is equal to another, then it is also a term of
the other type.  The equality judgment is defined in
Fig.~\ref{fig:CoC_beta_eq}.  We did not define this equality judgment
for PTS' above, because it is equivalent to this judgment.
\begin{figure}
  \begin{center}
    \begin{math}
      \begin{array}{lll}
        \CoCdruleEqXXBeta{} & \CoCdruleEqXXProd{}\\
        &\\
        \CoCdruleEqXXLam{} & \CoCdruleEqXXApp{}\\
        &\\
        \CoCdruleEqXXRefl{} & \CoCdruleEqXXSym{}\\
        &\\
        \CoCdruleEqXXTrans{}
      \end{array}
    \end{math}
  \end{center}
  \caption{$\beta$-Equality for the Calculus of Constructions}
  \label{fig:CoC_beta_eq}
\end{figure}
