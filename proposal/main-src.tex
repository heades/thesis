\usepackage{amsmath,amssymb,amsthm,amstext}
\usepackage{mathpartir}
\usepackage{vmargin}
\usepackage{enumitem}
\usepackage{url}
\usepackage{todonotes}
\usepackage{listings}
\usepackage{stmaryrd} 
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{hyperref}
\usetikzlibrary{arrows}
\usetikzlibrary{shapes}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{example}[theorem]{Example}

\newcommand{\redto}[0]{\rightsquigarrow}
\newcommand{\interp}[1]{\llbracket #1 \rrbracket}
\newcommand{\ifrName}[1]{#1}
\newcommand{\Sep}[0]{\text{Sep}^3}

\newcommand{\chcalc}[0]{\bar{\lambda}\mu\tilde{\mu}}

\newcommand{\cse}[0]{\noindent\underline{\textbf{Case:}}\ }


\newcommand{\ndto}[1]{\to_{#1}}
\newcommand{\ndwedge}[1]{\wedge_{#1}}

\newcommand{\To}[0]{\Rightarrow}

\begin{document}

\title{Semantic Analysis of Advanced Programming Languages}

\author{Harley Eades III\\ Computer Science\\ The University of Iowa}

\date{}

\maketitle

\section{Introduction}
\label{sec:introduction}
There are two major problems growing in two areas.  The first is in
Computer Science, in particular software engineering. Software is
becoming more and more complex, and hence more susceptible to software
defects.  Software bugs have two critical repercussions: they cost
companies lots of money and time to fix, and they have the potential
to cause harm. 

The National Institute of Standards and Technology estimated that
software errors cost the United State's economy approximately sixty
billion dollars annually, while the Federal Bureau of Investigations
estimated in a 2005 report that software bugs cost U.S. companies
approximately sixty-seven billion a year \cite{nist02,fbi05}.

Software bugs have the potential to cause harm.  In 2010 there were a
approximately a hundred reports made to the National Highway Traffic
Safety Administration of potential problems with the braking system of
the 2010 Toyota Prius \cite{Consumer:2010}.  The problem was that the
anti-lock braking system would experience a ``short delay'' when
the brakes where pressed by the driver of the vehicle
\cite{thedetroitbureau.com:2009}.  This actually caused some crashes.
Toyota found that this short delay was the result of a software bug,
and was able to repair the the vehicles using a software update
\cite{Reuters:2009}.  Another incident where substantial harm was
caused was in 2002 where two planes collided over \"{U}berlingen in
Germany. A cargo plane operated by DHL collided with a passenger
flight holding fifty-one passengers.  Air-traffic control did not
notice the intersecting traffic until less than a minute before the
collision occurred.  Furthermore, the on-board collision detection
system did not alert the pilots until seconds before the collision.
It was officially ruled by the German Federal Bureau of Aircraft
Accidents Investigation that the on-board collision detection was
indeed faulty \cite{Collision:2004}.

The second major problem affects all of science.  Scientific
publications are riddled with errors.  A portion of these errors are
mathematical.  In 2012 Casey Klein et al. used specialized computer
software to verify the correctness of nine papers published in the
proceedings of the International Conference on Functional Programming
(ICFP).  Two of the papers where used as a control which where known
to have been formally verified before.  In their paper
\cite{Klein:2012} they show that all nine papers contained
mathematical errors.  This is disconcerting especially since most
researchers trust published work and base their own work off of these
papers.  Kline's work shows that trusting published work might result
in wasted time for the researchers basing their work off of these
error prone publications.  Faulty research hinders scientific
progress.

Both problems outlined above have been the focus of a large body of
research over the course of the last forty years.  These challenges
have yet to be completed successfully.  The work I present here makes
up the foundations of one side of the programs leading the initiative
to build theory and tools which can be used to verify the correctness
of software and mathematics.  This program is called program
verification using dependent type theories.  The second program is
automated theorem proving.  In this program researchers build tools
called model checkers and satisfiability modulo-theories solvers.
These tools can be used to model and prove properties of large complex
systems carrying out proofs of the satisfiability of certain
constraints on the system nearly automatically, and in some cases
fully automatically.  As an example Andr\'{e} Platzer and Edmund
Clarke in 2009 used automated theorem proving to verify the
correctness of the in flight collision detection systems used in
airplanes.  They actually found that there were cases where two plans
could collide, and gave a way to fix the problem resulting in a fully
verified algorithm for collision detection.  That is he mathematically
proved that there is no possible way for two plans to collide if the
systems are operational \cite{DBLP:conf/fm/PlatzerC09}.  Automated
theorem provers, however, are tools used to verify the correctness of
software externally to the programming language and compiler one uses
to write the software.  In contrast with verification using dependent
types we wish to include the ability to verify software within the
programming language being used to write the software. Both programs
have their merits and are very fruitful and interesting.

This report summarizes my dissertation by chapter, section, and
subsection.  Each section will be given the name of a chapter, and
then the contents of the section will consist of a summery of that
chapter.  Similarly, for subsections.  I make sure to include my
already published work as well as on going work that needs to be done
before my defense.  My thesis will be broken into three main chapters.
The first, gives a history of type theory, and the necessary
background to facilitate understanding of the main results. The second
chapter is on the design of new advanced functional programming
languages.  Finally, the third covers the meta-theoretic analysis of
various type theories and functional programming languages.
% section introduction (end)

\section{Chapter 0: History and Background}
\label{sec:history_and_background}
This chapter provides a brief history of type theory as a foundation
of mathematics and typed-functional programming languages.  It begins
with Bertrand Russell -- the founder of type theory -- and introduces
key results up to the present. This chapter also serves as an
introduction of all the necessary concepts to understand the remainder
of the thesis.  I make sure and present each type theory in its
entirety and rigorously.  In fact every language defined in the thesis
will be formally defined in Ott \cite{Sewell:2010}.  Ott is a tool for
writing definitions of programming languages, type theories, and
$\lambda$-calculi.  Ott generates a parser and a type checker which is
used to check the accuracy of all objects definable with in the
language given to Ott as input.  Ott's strongest application is to
check for syntax errors within research articles.  Ott is a great
example of a tool using the very theory I will present in my thesis.
It clearly stands as a successful step towards the solution of the
second major problem outlined in the introduction.  Lastly, this
history and background has all been written and was presented as my
comprehensive exam.
% section history_and_background (end)

\section{Chapter I: Design}
\label{sec:design}

This chapter presents the design of a two general-purpose
dependently-typed functional programming languages called Freedom of
Speech, and Separation of Proof from Program, and a new constructive
type theory with constructive control called Dualized Type Theory.
This chapter will have a section per language. All the work with
respect to the first two languages is complete although mostly
unpublished.  The language of Dualized Type Theory is stabilizing, but
its analysis is on going work \cite{Stump:2013}.

The TRELLYS project is a collaboration between the University of Iowa,
University of Pennsylvania, and Portland State University to design a
new general-purpose dependently-typed functional programming language
that supports type-based verification.  What sets TRELLYS apart from
other similar projects is that it contains a number of advanced
features within the same language.  For example, mixing type-based
verification with general recursion is not well understood.  This
mixture is one of the primary aims of this project.  TRELLYS was
designed from the bottom up.  We started with a small trusted language
called the core, and then, after the core was finished, we would build
a surface language on top of it. Then the latter would elaborate into
the former.  My primary contribution to this project was to the design
and analysis of the core.  I helped with the design and analysis of
two core languages.  The first is Freedom of Speech.

\subsection{Freedom of Speech}
\label{subsec:freedom_of_speech}
The main objective of the TRELLYS project is to design a functional
programming language with two discernible fragments: a logical
fragment, and a programmatic fragment.  The programmatic fragment is a
general purpose dependently-type functional programming language.
This is a Turing-complete language with general recursion.  In
addition it contains the type in type axiom which leads to paradoxes
\cite{Coquand:1986,Coquand:1994}.  This axiom allows for the
definition of generic programs.  Now the logical fragment is the
fragment that can be used to prove properties about the programs
defined in the programmatic fragment.  In order for this fragment to
be considered a logic it must terminating.  Meaning every program
written in the this fragment must terminate in general.  This property
guarantees that the logic is consistent.

Recall that the three perspectives of computation\footnote{Also known
  as the Curry-Howard correspondence, and the propositions-as-types
  proofs-as-programs correspondence.} tell us that programs are proofs
and their types are propositions.  The most significant feature of
Freedom of Speech is that logical types can contain programs from the
programmatic fragment, but they are never allowed to be applied to any
arguments.  Thus, the logical fragment is allowed to ``talk'' about
the programmatic fragment.  This property we call free speech.

This section introduces the Freedom of Speech language and discusses
its design.  The analysis of this language greatly influenced its
design.  I discuss the analysis in
Section~\ref{subsubsec:free_speech}.  Interesting properties of this
design include: implicit arguments, the free speech property, a
collapsed syntax, and judgmental fragmentation into the logical and
programmatic fragment.
% subsection freedom_of_speech (end)

\subsection{Separation of Proof from Program ($\Sep$) }
\label{subsec:separation_of_proof_from_program}

% subsection separation_of_proof_from_program (end)

\subsection{Dualized Type Theory (DTT)}
\label{subsec:dualized_type_theory}
Constructive control operators are control operators -- operators that
have the ability to discard evaluation contexts -- that have been
restricted to discarding only certain context so as to remain
constructive.
% subsection dualized_type_theory_(dtt) (end)

% section design (end)

\section{Chapter II: Analysis}
\label{sec:analysis}

\subsection{Basic Analysis}
\label{subsec:basic_analysis}
\subsubsection{Free Speech}
\label{subsubsec:free_speech}

% subsection free_speech (end)

\subsubsection{Dualized Type Theory}
\label{subsubsec:dtt}

% subsection the_analysis_of_dtt (end)
% subsection basic_analysis (end)

\subsection{Normalization by Hereditary Substitution}
\label{subsec:normalization_by_hereditary_substitution}
\subsubsection{Stratified System F (SSF) and its Extensions}
\label{subsec:stratified_system_f_ext}

% subsubsection stratified_system_f_ext (end)

\subsubsection{The $\lambda\Delta$-Calculus}
\label{subsec:the_lambdadelta-calculus}

% subsubsection the_lambdadelta-calculus (end)

% subsection normalization_by_hereditary_substitution (end)

\subsection{Categorical Semantics}
\label{subsec:categorical_semantics}
\subsubsection{Semi-Bilinear Logic}
\label{subsec:semi-bilinear_logic}

% subsubsection semi-bilinear_logic (end)

\subsubsection{Split Bi-Intuitionistic Logic}
\label{subsec:split_bi-intuitionistic_logic}

% subsubsection split_bi-intuitionistic_logic (end)

\subsubsection{Dualized Type Theory}
\label{subsubsec:dualized_type_theory}

% subsection dualized_type_theory (end)

\subsubsection{Nested Bi-Intuitionistic Logic}
\label{subsec:nested_bi-intuitionistic_logic}

% subsubsection nested_bi-intuitionistic_logic (end)

% subsection categorical_semantics (end)

% section analysis (end)
 
\section{Conclusion}
\label{sec:conclusion}

% section conclusion (end)

\bibliographystyle{plain} \bibliography{biblio}

