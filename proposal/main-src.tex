\usepackage{amsmath,amssymb,amsthm,amstext}
\usepackage{mathpartir}
\usepackage{vmargin}
\usepackage{enumitem}
\usepackage{url}
\usepackage{todonotes}
\usepackage{listings}
\usepackage{stmaryrd} 
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{hyperref}
\usetikzlibrary{arrows}
\usetikzlibrary{shapes}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{example}[theorem]{Example}

\newcommand{\redto}[0]{\rightsquigarrow}
\newcommand{\interp}[1]{\llbracket #1 \rrbracket}
\newcommand{\ifrName}[1]{#1}
\newcommand{\Sep}[0]{\text{Sep}^3}

\newcommand{\chcalc}[0]{\bar{\lambda}\mu\tilde{\mu}}

\newcommand{\cse}[0]{\noindent\underline{\textbf{Case:}}\ }


\newcommand{\ndto}[1]{\to_{#1}}
\newcommand{\ndwedge}[1]{\wedge_{#1}}

\newcommand{\To}[0]{\Rightarrow}

\begin{document}

\title{Semantic Analysis of Advanced Programming Languages}

\author{Harley Eades III\\ Computer Science\\ The University of Iowa}

\date{}

\maketitle

\section{Introduction}
\label{sec:introduction}
There are two major problems growing in two areas.  The first is in
Computer Science, in particular software engineering. Software is
becoming more and more complex, and hence more susceptible to software
defects.  Software bugs have two critical repercussions: they cost
companies lots of money and time to fix, and they have the potential
to cause harm. 

The National Institute of Standards and Technology estimated that
software errors cost the United State's economy approximately sixty
billion dollars annually, while the Federal Bureau of Investigations
estimated in a 2005 report that software bugs cost U.S. companies
approximately sixty-seven billion a year \cite{nist02,fbi05}.

Software bugs have the potential to cause harm.  In 2010 there were a
approximately a hundred reports made to the National Highway Traffic
Safety Administration of potential problems with the braking system of
the 2010 Toyota Prius \cite{Consumer:2010}.  The problem was that the
anti-lock braking system would experience a ``short delay'' when
the brakes where pressed by the driver of the vehicle
\cite{thedetroitbureau.com:2009}.  This actually caused some crashes.
Toyota found that this short delay was the result of a software bug,
and was able to repair the the vehicles using a software update
\cite{Reuters:2009}.  Another incident where substantial harm was
caused was in 2002 where two planes collided over \"{U}berlingen in
Germany. A cargo plane operated by DHL collided with a passenger
flight holding fifty-one passengers.  Air-traffic control did not
notice the intersecting traffic until less than a minute before the
collision occurred.  Furthermore, the on-board collision detection
system did not alert the pilots until seconds before the collision.
It was officially ruled by the German Federal Bureau of Aircraft
Accidents Investigation that the on-board collision detection was
indeed faulty \cite{Collision:2004}.

The second major problem affects all of science.  Scientific
publications are riddled with errors.  A portion of these errors are
mathematical.  In 2012 Casey Klein et al. used specialized computer
software to verify the correctness of nine papers published in the
proceedings of the International Conference on Functional Programming
(ICFP).  Two of the papers where used as a control which where known
to have been formally verified before.  In their paper
\cite{Klein:2012} they show that all nine papers contained
mathematical errors.  This is disconcerting especially since most
researchers trust published work and base their own work off of these
papers.  Kline's work shows that trusting published work might result
in wasted time for the researchers basing their work off of these
error prone publications.  Faulty research hinders scientific
progress.

Both problems outlined above have been the focus of a large body of
research over the course of the last forty years.  These challenges
have yet to be completed successfully.  The work I present here makes
up the foundations of one side of the programs leading the initiative
to build theory and tools which can be used to verify the correctness
of software and mathematics.  This program is called program
verification using dependent type theories.  The second program is
automated theorem proving.  In this program researchers build tools
called model checkers and satisfiability modulo-theories solvers.
These tools can be used to model and prove properties of large complex
systems carrying out proofs of the satisfiability of certain
constraints on the system nearly automatically, and in some cases
fully automatically.  As an example Andr\'{e} Platzer and Edmund
Clarke in 2009 used automated theorem proving to verify the
correctness of the in flight collision detection systems used in
airplanes.  They actually found that there were cases where two plans
could collide, and gave a way to fix the problem resulting in a fully
verified algorithm for collision detection.  That is he mathematically
proved that there is no possible way for two plans to collide if the
systems are operational \cite{DBLP:conf/fm/PlatzerC09}.  Automated
theorem provers, however, are tools used to verify the correctness of
software externally to the programming language and compiler one uses
to write the software.  In contrast with verification using dependent
types we wish to include the ability to verify software within the
programming language being used to write the software. Both programs
have their merits and are very fruitful and interesting.

This report summarizes my dissertation by chapter.  Each section will
be given the name of a chapter, and then the contents of the section
will consist of a summery of that chapter.  I make sure to include my
already published work as well as on going work that needs to be done
before my defense.  My thesis will be broken into three main chapters.
The first, gives a history of type theory, and the necessary
background to facilitate understanding of the main results. The second
chapter is on the design of new advanced functional programming
languages.  Finally, the third covers the meta-theoretic analysis of
various type theories and functional programming languages.
% section introduction (end)

\section{Chapter 0: History and Background}
\label{sec:history_and_background}

% section history_and_background (end)

\section{Chapter I: Design}
\label{sec:design}

\subsection{Freedom of Speech}
\label{subsec:freedom_of_speech}

% subsection freedom_of_speech (end)

\subsection{Separation of Proof from Program ($\Sep$) }
\label{subsec:separation_of_proof_from_program}

% subsection separation_of_proof_from_program (end)

\subsection{Dualized Type Theory (DTT)}
\label{subsec:dualized_type_theory}

% subsection dualized_type_theory_(dtt) (end)

% section design (end)

\section{Chapter II: Analysis}
\label{sec:analysis}

\subsection{Basic Analysis}
\label{subsec:basic_analysis}
\subsubsection{Free Speech}
\label{subsubsec:free_speech}

% subsection free_speech (end)

\subsubsection{Dualized Type Theory}
\label{subsubsec:dtt}

% subsection the_analysis_of_dtt (end)
% subsection basic_analysis (end)

\subsection{Normalization by Hereditary Substitution}
\label{subsec:normalization_by_hereditary_substitution}
\subsubsection{Stratified System F (SSF) and its Extensions}
\label{subsec:stratified_system_f_ext}

% subsubsection stratified_system_f_ext (end)

\subsubsection{The $\lambda\Delta$-Calculus}
\label{subsec:the_lambdadelta-calculus}

% subsubsection the_lambdadelta-calculus (end)

% subsection normalization_by_hereditary_substitution (end)

\subsection{Categorical Semantics}
\label{subsec:categorical_semantics}
\subsubsection{Semi-Bilinear Logic}
\label{subsec:semi-bilinear_logic}

% subsubsection semi-bilinear_logic (end)

\subsubsection{Split Bi-Intuitionistic Logic}
\label{subsec:split_bi-intuitionistic_logic}

% subsubsection split_bi-intuitionistic_logic (end)

\subsubsection{Dualized Type Theory}
\label{subsubsec:dualized_type_theory}

% subsection dualized_type_theory (end)

\subsubsection{Nested Bi-Intuitionistic Logic}
\label{subsec:nested_bi-intuitionistic_logic}

% subsubsection nested_bi-intuitionistic_logic (end)

% subsection categorical_semantics (end)

% section analysis (end)
 
\section{Conclusion}
\label{sec:conclusion}

% section conclusion (end)

\bibliographystyle{plain}
\bibliography{biblio}

